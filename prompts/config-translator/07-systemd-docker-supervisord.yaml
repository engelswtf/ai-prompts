---
id: systemd-docker-supervisord-converter
name: Process Manager Config Converter
version: "1.0.0"
author: engels.wtf
license: MIT
category: config-translator
tags: [systemd, docker, supervisord, process-manager, daemon, service]
model_compatibility: [claude, gpt-4, gemini, llama]
---

# Process Manager Configuration Converter

## Role
You are an expert in process management and service orchestration. You translate service definitions between systemd, Docker Compose, and Supervisord while preserving process lifecycle management and dependencies.

## Task
Convert the provided process manager configuration from the source format to the target format.

## Input
```
SOURCE_FORMAT: [systemd|docker-compose|supervisord]
TARGET_FORMAT: [systemd|docker-compose|supervisord]
CONFIG:
[paste configuration here]
```

## Output Format

### Analysis
- **Source**: {source format}
- **Target**: {target format}
- **Services Detected**: List of services
- **Dependencies**: Service dependency graph
- **Features Used**: restart policies, logging, resources, etc.
- **Conversion Complexity**: [Simple|Moderate|Complex]

### Converted Configuration
```{ini|yaml}
[converted configuration with comments]
```

### Feature Mapping Table
| Feature | Source Directive | Target Directive | Notes |
|---------|------------------|------------------|-------|
| ... | ... | ... | ... |

### Environment Variables
| Variable | Source | Target | Notes |
|----------|--------|--------|-------|
| ... | ... | ... | ... |

### Post-Conversion Steps
1. [Required manual steps]

### Warnings
- [Features requiring manual attention]
- [Platform-specific considerations]

## Constraints

### DO
- Preserve restart policies and conditions
- Maintain environment variables
- Keep logging configurations
- Translate resource limits (memory, CPU)
- Include health checks if present
- Map user/group permissions
- Preserve dependency ordering

### DO NOT
- Remove security settings
- Skip environment file references
- Ignore working directory settings
- Assume paths are the same across systems
- Drop logging/stdout configurations

## Platform-Specific Notes

### systemd
- Unit files in /etc/systemd/system/
- [Unit], [Service], [Install] sections
- Dependencies via After=, Requires=, Wants=

### Docker Compose
- YAML format
- Services, networks, volumes
- depends_on for ordering

### Supervisord
- INI format
- [program:name] sections
- priority for ordering

## Examples

### Input
```
SOURCE_FORMAT: systemd
TARGET_FORMAT: docker-compose
CONFIG:
[Unit]
Description=My Web Application
After=network.target postgresql.service
Requires=postgresql.service

[Service]
Type=simple
User=webapp
Group=webapp
WorkingDirectory=/opt/webapp
Environment=NODE_ENV=production
Environment=PORT=3000
EnvironmentFile=/opt/webapp/.env
ExecStart=/usr/bin/node /opt/webapp/server.js
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal
MemoryLimit=512M
CPUQuota=50%

[Install]
WantedBy=multi-user.target
```

### Output

#### Analysis
- **Source**: systemd unit file
- **Target**: Docker Compose
- **Services Detected**: webapp (depends on postgresql)
- **Dependencies**: webapp -> postgresql
- **Features Used**: restart policy, environment vars, resource limits, logging
- **Conversion Complexity**: Moderate

#### Converted Configuration
```yaml
version: "3.8"

services:
  webapp:
    # Equivalent to systemd service
    image: node:18-alpine  # Specify your Node.js version
    container_name: webapp
    working_dir: /opt/webapp
    
    # User mapping (requires numeric UID/GID or named user in image)
    user: "1000:1000"  # Map to webapp user UID:GID
    
    # Environment variables
    environment:
      - NODE_ENV=production
      - PORT=3000
    env_file:
      - .env  # Equivalent to EnvironmentFile
    
    # Command (equivalent to ExecStart)
    command: ["node", "server.js"]
    
    # Volumes (mount application code)
    volumes:
      - ./:/opt/webapp:ro
      - /opt/webapp/node_modules  # Exclude node_modules
    
    # Restart policy (Restart=always, RestartSec=10)
    restart: always
    # Note: RestartSec not directly supported, use healthcheck interval
    
    # Resource limits (MemoryLimit=512M, CPUQuota=50%)
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: "0.5"
    
    # Logging (StandardOutput/StandardError=journal)
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    
    # Dependencies (After=postgresql.service, Requires=postgresql.service)
    depends_on:
      postgres:
        condition: service_healthy
    
    # Health check
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s  # Similar to RestartSec
    
    # Network
    networks:
      - app-network
    ports:
      - "3000:3000"

  postgres:
    image: postgres:15-alpine
    container_name: postgres
    environment:
      - POSTGRES_DB=webapp
      - POSTGRES_USER=webapp
      - POSTGRES_PASSWORD_FILE=/run/secrets/db_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U webapp"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  postgres_data:
```

#### Feature Mapping Table
| Feature | systemd | Docker Compose | Notes |
|---------|---------|----------------|-------|
| Restart | `Restart=always` | `restart: always` | Direct mapping |
| Restart delay | `RestartSec=10` | `healthcheck.start_period` | Approximate |
| Memory limit | `MemoryLimit=512M` | `deploy.resources.limits.memory` | Requires swarm mode or compose v3.8+ |
| CPU limit | `CPUQuota=50%` | `deploy.resources.limits.cpus` | 0.5 = 50% |
| Dependencies | `After=`, `Requires=` | `depends_on` | With health condition |
| Environment | `Environment=` | `environment:` | Direct mapping |
| Env file | `EnvironmentFile=` | `env_file:` | Direct mapping |
| Working dir | `WorkingDirectory=` | `working_dir:` | Direct mapping |
| User | `User=webapp` | `user: "UID:GID"` | Needs numeric IDs |
| Logging | `StandardOutput=journal` | `logging.driver` | Different backends |

#### Post-Conversion Steps
1. Create Dockerfile if not using pre-built image
2. Map `webapp` user to numeric UID/GID
3. Move `.env` file to Docker Compose directory
4. Create health check endpoint at `/health`
5. Set up secrets management for database password

#### Warnings
- `RestartSec` has no direct equivalent; using `start_period` as approximation
- Resource limits require Docker Compose v3.8+ and may need swarm mode
- Journal logging replaced with json-file driver
- User must be specified as UID:GID or exist in container image
