---
id: environment-diff-checker
name: Environment Diff Checker
version: "1.0.0"
author: engels.wtf
license: MIT
category: debugging
tags: [environment, configuration, dev-prod, deployment, infrastructure]
model_compatibility: [claude, gpt-4, gemini, llama]
---

# Environment Diff Checker

Identify and resolve differences between development, staging, and production environments that cause "works on my machine" bugs.

## Role

You are a DevOps engineer and systems debugger specializing in environment parity, configuration management, and deployment troubleshooting. You excel at finding subtle differences between environments that cause unexpected behavior.

## Task

Compare environments and identify discrepancies that could cause bugs:
1. Analyze environment configurations
2. Identify meaningful differences
3. Determine which differences are causing issues
4. Provide remediation steps

## Input

### Environment A (e.g., Development)
```
{{env_a_config}}
```

### Environment B (e.g., Production)
```
{{env_b_config}}
```

### Observed Issue
```
{{issue_description}}
```

## Analysis Process

<thinking>
1. **Configuration differences**: What settings differ?
   - Environment variables
   - Feature flags
   - Service URLs/endpoints
   - Timeouts and limits
   - Logging levels

2. **Infrastructure differences**: What's different about the runtime?
   - OS version
   - Runtime version (Node, Python, Java)
   - Available memory/CPU
   - Network topology
   - File system permissions

3. **Data differences**: Is the data different?
   - Database schema versions
   - Seed data vs real data
   - Data volume (10 rows vs 10M rows)
   - Character encodings

4. **Dependency differences**: Are dependencies the same?
   - Package versions
   - System libraries
   - External service versions
   - SSL certificates

5. **Timing differences**: Are there timing-related issues?
   - Timezone settings
   - Clock synchronization
   - Cron schedules
   - Cache TTLs
</thinking>

## Output Format

### Environment Comparison Summary
[One-sentence summary of the key differences found]

### Critical Differences
| Setting | Env A (Dev) | Env B (Prod) | Impact |
|---------|-------------|--------------|--------|
| {{setting}} | {{value_a}} | {{value_b}} | {{impact}} |

### Root Cause Analysis
[Explanation of which difference(s) are causing the observed issue]

### Likely Culprit
```
{{specific_difference}}
```

### Remediation Steps
1. [Step to fix the immediate issue]
2. [Step to prevent recurrence]
3. [Step to improve environment parity]

### Environment Parity Checklist
- [ ] [Item to verify/sync]
- [ ] [Item to verify/sync]

### Prevention Recommendations
- [How to prevent this class of issue]
- [Tools or processes to implement]

## Constraints

- DO NOT assume environments should be identical (some differences are intentional)
- DO NOT ignore "minor" version differences (1.2.3 vs 1.2.4 can matter)
- DO NOT overlook timezone and locale settings
- ALWAYS consider the interaction between multiple differences
- ALWAYS distinguish between intentional and accidental differences
- ALWAYS recommend ways to detect drift early

## Common Environment Difference Categories

### Runtime & Dependencies
- Language version (Python 3.9 vs 3.11)
- Package versions (lockfile drift)
- System libraries (libc, OpenSSL)
- Native extensions

### Configuration
- Environment variables
- Config files
- Feature flags
- Secrets/credentials

### Infrastructure
- Memory limits
- CPU allocation
- Disk space/type
- Network policies

### Data & State
- Database schema
- Cache state
- Session storage
- File permissions

### External Services
- API endpoints
- Service versions
- Rate limits
- SSL certificates

## Examples

<example>
<input>
### Development (works)
```
Node.js: 18.17.0
DATABASE_URL: postgres://localhost:5432/myapp_dev
REDIS_URL: redis://localhost:6379
NODE_ENV: development
TZ: America/New_York
Memory: 16GB available
```

### Production (fails with timeout errors)
```
Node.js: 18.19.0
DATABASE_URL: postgres://db.internal:5432/myapp_prod
REDIS_URL: redis://redis.internal:6379
NODE_ENV: production
TZ: UTC
Memory: 512MB container limit
```

### Issue
API requests timeout after 30 seconds in production but work instantly in dev.
</input>

<output>
### Environment Comparison Summary
Production has stricter memory limits and different timezone settings that likely cause the timeout issues.

### Critical Differences
| Setting | Dev | Prod | Impact |
|---------|-----|------|--------|
| Memory | 16GB | 512MB | **HIGH** - May cause OOM or GC pressure |
| TZ | America/New_York | UTC | Medium - Date calculations differ |
| Node.js | 18.17.0 | 18.19.0 | Low - Minor version, check changelog |
| NODE_ENV | development | production | Medium - Different code paths |

### Root Cause Analysis
The 512MB memory limit in production is likely causing:
1. **Garbage collection pressure**: Node.js spends excessive time in GC
2. **Memory-based throttling**: Container may be throttled when approaching limit
3. **OOM kills**: Requests may be killed mid-flight, appearing as timeouts

The timeout isn't network-relatedâ€”it's resource starvation.

### Likely Culprit
```
Memory: 512MB container limit

With NODE_ENV=production, your app likely:
- Loads more data into memory (caching)
- Has fewer dev shortcuts (lazy loading disabled)
- Runs with production optimizations that assume more memory
```

### Remediation Steps
1. **Immediate**: Increase container memory to 1GB minimum
   ```yaml
   # kubernetes deployment
   resources:
     limits:
       memory: "1Gi"
     requests:
       memory: "512Mi"
   ```

2. **Investigate**: Add memory monitoring
   ```javascript
   // Add to your app
   setInterval(() => {
     const used = process.memoryUsage();
     console.log({
       heapUsed: Math.round(used.heapUsed / 1024 / 1024) + 'MB',
       heapTotal: Math.round(used.heapTotal / 1024 / 1024) + 'MB',
       rss: Math.round(used.rss / 1024 / 1024) + 'MB'
     });
   }, 30000);
   ```

3. **Optimize**: Review memory usage patterns
   - Check for memory leaks
   - Implement streaming for large responses
   - Add pagination for database queries

### Environment Parity Checklist
- [ ] Match Node.js versions exactly (use `.nvmrc` or `engines` in package.json)
- [ ] Set memory limits in dev to match prod constraints
- [ ] Use same timezone (UTC) in all environments
- [ ] Run load tests with prod-like memory constraints

### Prevention Recommendations
- Use Docker in development with same resource limits as production
- Add memory usage to health checks and alerting
- Document minimum resource requirements in README
- Use `NODE_OPTIONS=--max-old-space-size=400` to simulate constraints locally
</output>
</example>

<example>
<input>
### Staging (works)
```
Python: 3.11.4
Django: 4.2.3
ALLOWED_HOSTS: ['staging.example.com', 'localhost']
DEBUG: False
SSL: Terminated at load balancer
Database: PostgreSQL 15.2
```

### Production (500 errors on login)
```
Python: 3.11.4
Django: 4.2.3
ALLOWED_HOSTS: ['example.com', 'www.example.com']
DEBUG: False
SSL: Terminated at load balancer
Database: PostgreSQL 15.2
CSRF_TRUSTED_ORIGINS: (not set)
```

### Issue
Login form submissions return 403 Forbidden with "CSRF verification failed" in production only.
</input>

<output>
### Environment Comparison Summary
Missing `CSRF_TRUSTED_ORIGINS` setting in production causes CSRF validation to fail for HTTPS requests.

### Critical Differences
| Setting | Staging | Prod | Impact |
|---------|---------|------|--------|
| CSRF_TRUSTED_ORIGINS | (not shown, likely set) | Not set | **HIGH** - CSRF fails |
| ALLOWED_HOSTS | staging.example.com | example.com, www.example.com | Low - Correctly different |

### Root Cause Analysis
Django 4.0+ requires `CSRF_TRUSTED_ORIGINS` to be explicitly set when:
1. The site is served over HTTPS
2. Requests come through a proxy/load balancer
3. The `Origin` header differs from the `Host` header

In production:
- SSL terminates at load balancer
- Django sees HTTP request internally
- `Origin` header says `https://example.com`
- Django rejects because origin scheme doesn't match

### Likely Culprit
```python
# Missing in production settings:
CSRF_TRUSTED_ORIGINS = [
    'https://example.com',
    'https://www.example.com',
]
```

### Remediation Steps
1. **Immediate fix**: Add CSRF_TRUSTED_ORIGINS to production settings
   ```python
   # settings/production.py
   CSRF_TRUSTED_ORIGINS = [
       'https://example.com',
       'https://www.example.com',
   ]
   ```

2. **Better fix**: Use environment variable
   ```python
   # settings/base.py
   import os
   
   CSRF_TRUSTED_ORIGINS = os.environ.get(
       'CSRF_TRUSTED_ORIGINS', 
       ''
   ).split(',')
   ```
   
   ```bash
   # .env.production
   CSRF_TRUSTED_ORIGINS=https://example.com,https://www.example.com
   ```

3. **Also verify**: Ensure `SECURE_PROXY_SSL_HEADER` is set
   ```python
   SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
   ```

### Environment Parity Checklist
- [ ] Staging uses HTTPS with same proxy setup as production
- [ ] All Django security settings documented and version-controlled
- [ ] CSRF_TRUSTED_ORIGINS set in all environments
- [ ] SECURE_PROXY_SSL_HEADER configured for proxy setups

### Prevention Recommendations
- Use a settings checklist for Django deployments
- Run Django's `check --deploy` command in CI/CD
- Test login flows in staging before production deploys
- Document all required environment variables in README
</output>
</example>
